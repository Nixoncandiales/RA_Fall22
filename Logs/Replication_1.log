------------------------------------------------------------------------------------------------------------------------------------
      name:  <unnamed>
       log:  C:\Users\16083\Documents\Github\RA_FALL22\Logs/Replication_1.log
  log type:  text
 opened on:  28 Sep 2022, 14:08:44

. 
. /****** Loading the data ************/
. use Data/analy_malp_paper_9_22.dta, clear

. xtset stfips year // Declaring it as a Panel

Panel variable: stfips (strongly balanced)
 Time variable: year, 1998 to 2019
         Delta: 1 unit

. 
. /* Define locals controls, torts, atorts */
. local x pctpoverty unemp rpcinc

. local torts jsl pcap necap apology

. local atorts pcap necap apology

. 
. /****** Define variables as in Woldrige (2021) ************/
. 
. /* d=1 if recieve the treatment. */
. gen d = (!missing(FPA_FULL_YEAR))

. label variable d "=1 if treated"

. 
. /* p=1 if post-treatment time */
. gen p = (pre==0)

. label variable p "=1 if post-treatment period"

. 
. /* w=d*p */
. gen w= (d*p)

. label variable w "=1 if treated & in post-treatment period"

. 
. /* year indicators */
. qui tab year, gen(f)

. rename f# f#, renumber(1998) // starting year in 1998

. unab i_year : f1* f2*           // varlist of year indicators

. 
. /* treatment cohort indicators */
. qui tab FPA_FULL_YEAR, gen(c)

. unab cohort : c*                        // varlist of cohort indicators

. 
. /* replacing missing values */
. foreach v of varlist c* {
  2.     qui replace `v' = 0 if `v' == .
  3. }

. 
. 
. /* Generate demeaned variables
> Generate new variables centered around cohort means
> Note to self:   THIS MUST BE DONE OVER CONSTANT VARIABLES !!! 
>                                 That is the reason I had a problem with my attemp. 
>                                 I was incluing a linear combination of the controls!!!!!!!!!
>                                 As a result the algorithm was not converging 
> 
> forvalues i = 1/14 {
>                 local x_dm`i'
>                 local y "x_dm`i'"
>                 foreach v in `x' {
>                         sum `v' if c`i'
>                         gen `v'_dm`i' = `v' - r(mean)
>                         label variable `v'_dm`i' "`v' demeaned at cohort `i'"
>                         local `y' `x_dm`i'' `v'_dm`i'
>                 }
> }
> 
> */
. 
. **# Main model - Poisson staggered entry case
. 
. /*  Estimate de model  
> The first set of regresors are interactions between treatment,cohort and post-treatment indicators;
> The second set of regresors are the interactions between treatment,cohort,post-treatment and controls centered around cohort means
>  (CONSTANT CONTROLS) indicators;
> The third set of regressors are indicators for year, cohort and interactions between year, cohort and controls.
> */
. 
. qui poisson malp_np i.w#c.c1#c.f1998-f2019 i.w#c.c2#c.f2000-f2019 i.w#c.c3#c.f2005-f2019 ///
>                                 i.w#c.c4#c.f2006-f2019 i.w#c.c5#c.f2010-f2019 i.w#c.c6#c.f2011-f2019 ///
>                                 i.w#c.c7#c.f2012-f2019 i.w#c.c8#c.f2013-f2019 i.w#c.c9#c.f2014-f2019 ///
>                                 i.w#c.c10#c.f2015-f2019 i.w#c.c11#c.f2016-f2019 i.w#c.c12#c.f2018-f2019 i.w#c.c13#c.f2019 ///
>                                 `i_year' c.`i_year'#c.`x' ///
>                                 `cohort' `x' c.c*#c.`x' , noomitted vce(cluster stfips)

. estimates store model1

.                                 /*      To include if we have constant controls over time
>                                 ///
>                                 w#c.c1#c.f1998-f2019#c.`x_dm1' w#c.c2#c.f2000-f2019#c.`x_dm2' ///
>                                 w#c.c3#c.f2005-f2019#c.`x_dm3' w#c.c4#c.f2006-f2019#c.`x_dm4' /// 
>                                 w#c.c5#c.f2010-f2019#c.`x_dm5' w#c.c6#c.f2011-f2019#c.`x_dm6' /// 
>                                 w#c.c7#c.f2012-f2019#c.`x_dm7' w#c.c8#c.f2013-f2019#c.`x_dm8' ///
>                                 w#c.c9#c.f2014-f2019#c.`x_dm9' w#c.c10#c.f2015-f2019#c.`x_dm10' ///
>                                 w#c.c11#c.f2016-f2019#c.`x_dm11' w#c.c12#c.f2018-f2019#c.`x_dm12'/// 
>                                 w#c.c13#c.f2019#c.`x_dm13' ///
>                                 */
.                                 
. **# ATT 
. /* To obtain ATTs using margins.
> 
> As in CS (2021) and Sun and Abraham (2021), the treatment effects to identify are the ATTs in periods 
> where the cohorts are actually subjected to the intervention. <- ATT come from pooled Poisson.->
> 
> We have to include w explicitly. Also, have to 
> set the cohort (c*)and year (i_year) indicators  accordingly
> 
> The following is the example provided by Wooldrige. Using Margins after possion 
> estimates the ATT at the cohort q in time t.
> 
> margins, dydx(w) at(d4 = 1 d5 = 0 d6 = 0 f02 = 0 f03 = 0 f04 = 1 f05 = 0 f06 = 0) ///
>         subpop(if d4 == 1) noestimcheck vce(uncond)
> margins, dydx(w) at(d4 = 1 d5 = 0 d6 = 0 f02 = 0 f03 = 0 f04 = 0 f05 = 1 f06 = 0) ///
>         subpop(if d4 == 1) noestimcheck vce(uncond)  
> margins, dydx(w) at(d4 = 1 d5 = 0 d6 = 0 f02 = 0 f03 = 0 f04 = 0 f05 = 0 f06 = 1) ///
>         subpop(if d4 == 1) noestimcheck vce(uncond) 
> margins, dydx(w) at(d4 = 0 d5 = 1 d6 = 0 f02 = 0 f03 = 0 f04 = 0 f05 = 1 f06 = 0) ///
>         subpop(if d5 == 1) noestimcheck vce(uncond)
> margins, dydx(w) at(d4 = 0 d5 = 1 d6 = 0 f02 = 0 f03 = 0 f04 = 0 f05 = 0 f06 = 1) ///
>         subpop(if d5 == 1) noestimcheck vce(uncond) 
> margins, dydx(w) at(d4 = 0 d5 = 0 d6 = 1 f02 = 0 f03 = 0 f04 = 0 f05 = 0 f06 = 1) ///
>         subpop(if d6 == 1) noestimcheck vce(uncond)
>         
> I tried to approach this ATT in a iterative way 
> to get reproducible results. 
> 
> In a simpler way I generate some inteactions for the cohort q in time t and indclude those in the model. 
> See next chunk. 
> */
. 
. * Generate  the interactions
. numlist "1/14"

. local y1 = "`r(numlist)'"

. 
. local n : word count `y1'

. levelsof FPA_FULL_YEAR, local(y2)
1998 2000 2005 2006 2010 2011 2012 2013 2014 2015 2016 2018 2019 2021

. 
.  forvalues i = 1/`n' {
  2.       local a : word `i' of `y1'
  3.       local b : word `i' of `y2'
  4.           forvalues j = `b'/2019{
  5.                 qui gen c`a'f`j' = c`a'*f`j'
  6.                 qui label variable c`a'f`j' "Cohort `a'"
  7.           }
  8.    }

. 
. *--------------------------------------------------------------------------------------------
. *------------------------- Estimate the model DEP VAR: mlp_np *------------------------------
. *--------------------------------------------------------------------------------------------
. qui poisson malp_np i.c1f* i.c2f* i.c3f* i.c4f* i.c5f* i.c6f* i.c7f* i.c8f* i.c9f* i.c10f* i.c11f* i.c12f* i.c13f* `i_year' ///
>                                         c.`i_year'#c.`x' `cohort' `x' c.c*#c.`x' , noomitted vce(cluster stfips)

.                                         /* To include if we have constant controls over time
>                                         i.c1f*#c.x_dm1 i.c2f*#c.x_dm3 i.c3f*#c.x_dm3 .... and so on for the demeaned variables
>                                         */
. estimates store model2 //store the estimates

. 
. * Example How to get the ATT at cohort 13 at time 2019
.         estimates restore model2
(results model2 are active now)

.         margins, dydx(1.c13f2019) subpop(if c13f2019== 1)  noestimcheck vce(uncond)     
warning: prediction constant over observations.

Average marginal effects                               Number of obs   = 1,122
                                                       Subpop. no. obs =     1

Expression: Predicted number of events, predict()
dy/dx wrt:  1.c13f2019

                                (Std. err. adjusted for 51 clusters in stfips)
------------------------------------------------------------------------------
             |            Unconditional
             |      dy/dx   std. err.      z    P>|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
    c13f2019 |
          0  |          0  (empty)
          1  |   -.904258   .2178977    -4.15   0.000     -1.33133   -.4771863
------------------------------------------------------------------------------
Note: dy/dx for factor levels is the discrete change from the base level.

.         margins, eydx(1.c13f2019) subpop(if c13f2019== 1)  noestimcheck vce(uncond)     
warning: prediction constant over observations.

Average marginal effects                               Number of obs   = 1,122
                                                       Subpop. no. obs =     1

Expression: Predicted number of events, predict()
ey/dx wrt:  1.c13f2019

                                (Std. err. adjusted for 51 clusters in stfips)
------------------------------------------------------------------------------
             |            Unconditional
             |      ey/dx   std. err.      z    P>|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
    c13f2019 |
          0  |          0  (empty)
          1  |  -16.29673   1.036403   -15.72   0.000    -18.32804   -14.26542
------------------------------------------------------------------------------
Note: ey/dx for factor levels is the discrete change from the base level.

. *       scalar tau13_2019 = _b[1.c13f2019]
. *       di "tau13_2019 " tau13_2019
. 
. /*      * Iterative approach to get the ATT over all cohorts and post-treatment period.
> */
. 
. /* Average Marginal Effect */
. numlist "1/14"

. local y1 = "`r(numlist)'"

. local n : word count `y1'

. levelsof FPA_FULL_YEAR, local(y2)
1998 2000 2005 2006 2010 2011 2012 2013 2014 2015 2016 2018 2019 2021

. postfile DyDx_mlp cohort time b se z pvalue ll ul using DyDx_mlp, replace 
(file DyDx_mlp.dta not found)

.  forvalues i = 1/`n' {
  2.       local a : word `i' of `y1'
  3.       local b : word `i' of `y2'
  4.           di "Estimating Average Marginal Effects - Cohort `a'" _cont
  5.           forvalues j = `b'/2019{
  6.                 qui estimates restore model2
  7.                 qui margins, dydx(1.c`a'f`j') subpop(if c`a'f`j'== 1) noestimcheck vce(uncond)
  8.                 local b = r(table)[1,2]
  9.                 local se = r(table)[2,2]
 10.                 local z = r(table)[3,2]
 11.                 local pvalue = r(table)[4,2]
 12.                 local ll = r(table)[5,2]
 13.                 local ul = r(table)[6,2]
 14.                 post DyDx_mlp (`a') (`j') (`b') (`se') (`z') (`pvalue') (`ll') (`ul')
 15.                 di "." _cont
 16.           }
 17.                 noi di _dup(10) "." _cont
 18.                 di "Done" _cont         
 19.                 noi di _dup(1) "!"
 20.    }
Estimating Average Marginal Effects - Cohort 1................................Done!
Estimating Average Marginal Effects - Cohort 2..............................Done!
Estimating Average Marginal Effects - Cohort 3.........................Done!
Estimating Average Marginal Effects - Cohort 4........................Done!
Estimating Average Marginal Effects - Cohort 5....................Done!
Estimating Average Marginal Effects - Cohort 6...................Done!
Estimating Average Marginal Effects - Cohort 7..................Done!
Estimating Average Marginal Effects - Cohort 8.................Done!
Estimating Average Marginal Effects - Cohort 9................Done!
Estimating Average Marginal Effects - Cohort 10...............Done!
Estimating Average Marginal Effects - Cohort 11..............Done!
Estimating Average Marginal Effects - Cohort 12............Done!
Estimating Average Marginal Effects - Cohort 13...........Done!
Estimating Average Marginal Effects - Cohort 14..........Done!

. postclose DyDx_mlp

. 
. 
. /* Semi Elasticity */
. numlist "1/14"

. local y1 = "`r(numlist)'"

. local n : word count `y1'

. levelsof FPA_FULL_YEAR, local(y2)
1998 2000 2005 2006 2010 2011 2012 2013 2014 2015 2016 2018 2019 2021

. postfile EyDx_mlp cohort time b se z pvalue ll ul using EyDx_mlp, replace 
(file EyDx_mlp.dta not found)

.  forvalues i = 1/`n' {
  2.       local a : word `i' of `y1'
  3.       local b : word `i' of `y2'
  4.           di "Estimating Predicted Number of Events - Cohort `a'" _cont
  5.           forvalues j = `b'/2019{
  6.                 qui estimates restore model2
  7.                 qui margins, eydx(1.c`a'f`j') subpop(if c`a'f`j'== 1) noestimcheck vce(uncond)
  8.                 local b = r(table)[1,2]
  9.                 local se = r(table)[2,2]
 10.                 local z = r(table)[3,2]
 11.                 local pvalue = r(table)[4,2]
 12.                 local ll = r(table)[5,2]
 13.                 local ul = r(table)[6,2]
 14.                 post EyDx_mlp (`a') (`j') (`b') (`se') (`z') (`pvalue') (`ll') (`ul')
 15.                 di "." _cont
 16.           }
 17.                 noi di _dup(10) "." _cont
 18.                 di "Done" _cont         
 19.                 noi di _dup(1) "!"
 20.    }
Estimating Predicted Number of Events - Cohort 1................................Done!
Estimating Predicted Number of Events - Cohort 2..............................Done!
